#!/bin/env python3

###############################################################################################
import os
import sys
import glob
import argparse
import traceback
import subprocess

from datetime import datetime
from oscap.scan.report import Report

###############################################################################################
VERBOSE = False

SCAP_SEC_TOOL = "scap-security-guide"
STIG_PROFILE = "xccdf_org.ssgproject.content_profile_stig"
DATA_STREAM_LOC = "/usr/share/xml/scap/ssg/content/ssg-ol8-ds.xml"
SCAN_STIG_HOME_DIR = "~/.scan_stig"

###############################################################################################

def validate_id(scan_id):
    """ Helper function to validate a given scan ID meets the build syntaxis

    The syntaxis for a valid scan ID is as follows:

        Date : %d%m%Y - 8 digits
            %d - Day of the month as a zero-padded decimal number.
            %m - Month as a zero-padded decimal number.
            %Y - Year with century as a decimal number.

        Time : %H%M%S - 6 digits
            %H - Hour (24-hour clock) as a zero-padded decimal number.
            %M - Minute as a zero-padded decimal number.
            %S - Second as a zero-padded decimal number.

        Consecutive number : #### - 4 digits
            Number from 0000 to 9999 taken.

    Parameters
    ----------
    scan_id : str
        Scan ID string made of date, time, and a consecutive number.

    Returns
    -------
    scan_id : str
        A valid scan ID
    """

    date_time = "%d%m%Y%H%M%S"

    msg = """
    Scan ID must be in the format ddmmYYHHMMSS###

    The syntaxis for a valid scan ID is as follows:

    Date : %d%m%Y - 8 digits
        %d - Day of the month as a zero-padded decimal number.
        %m - Month as a zero-padded decimal number.
        %Y - Year with century as a decimal number.

    Time : %H%M%S - 6 digits
        %H - Hour (24-hour clock) as a zero-padded decimal number.
        %M - Minute as a zero-padded decimal number.
        %S - Second as a zero-padded decimal number.

    Consecutive number : #### - 4 digits
        Number from 0000 to 9999 taken.
    """

    # Check only for numbers and lenght
    if not scan_id.isnumeric() or len(scan_id) is not 18:
        raise argparse.ArgumentTypeError(msg)

    # Check for a valid date
    try:
        # strptime does not check for zero-padded on month and day so double check it.
        if scan_id[:14] != datetime.strptime(scan_id[:14], date_time).strftime(date_time):
            print("2")
            raise argparse.ArgumentTypeError(msg)
    except ValueError:
        print("3")
        raise argparse.ArgumentTypeError(msg)

    return scan_id

###############################################################################################

def get_results():
    """
    Helper function to get a list of available reults
    """
    return glob.glob(f"{os.path.expanduser(SCAN_STIG_HOME_DIR)}/result_*.xml")

###############################################################################################

def print_scan_compare_summary(report1, report2):
    """
    Print a compare summary of two existing oscap report
    """

    if VERBOSE:
        print("print_scan_compare_summary")

    rules1 = report1.get_raw_executed_rules()
    rules2 = report2.get_raw_executed_rules()

    print("\nSummary statistics")
    # Get rules that only lives in the first report
    print("\n\tExtra rules ID 1")
    check = 1
    for rule in rules1:
        if not rule in rules2:
            print(f"\t\tRule\t: {rule}")
            check = 0
    if check:
        print("\t\tNone")
        check = 1
    
    # Get rules that only lives in the second report
    print("\n\tExtra rules ID 2")
    for rule in rules2:
        if not rule in rules1:
            print(f"\t\tRule\t: {rule}")
            check = 0
    if check:
        print("\t\tNone")
        check = 1
    
    # Get rules that lives in both reports with different results
    print("\n\tUnmatching results for the same rule")
    for rule in rules1:
        if rule in rules2 and rules1[rule] != rules2[rule]:
            print(f"\t\tRule\t: {rule}")
            print(f"\t\tID 1\t: {rules1[rule]}")
            print(f"\t\tID 2\t: {rules2[rule]}")
            print()
    if check:
        print("\t\tNone")
        check = 1

###############################################################################################

def print_scan_summary(scan_id_file, label=""):
    """
    Print a summary of an existing oscap report
    """

    if VERBOSE:
        print("print_scan_summary")

    report = Report(scan_id_file)

    print(f"\nSummary statistics {label}")
    print(f"\n\tID\t\t: {report}")
    print(f"\tDate\t\t: {report.get_scan_date()}")
    print(f"\tSystem Score\t: {report.get_score()}")
    print(f"\tTotal Rules\t: {report.get_executed_rules()}")
    print(f"\t\tPassed\t: {report.get_passed_rules()}")
    print(f"\t\tFailed\t: {report.get_failed_rules()}")

    return report

###############################################################################################

def get_new_scan_id():
    """
    Get from configuration directory the latest scan ID plus one and return it
    """

    if VERBOSE:
        print("get_last_scan_id")

    results = []
    for result in get_results():
        # Get the ID only and convert it do interger so we can sort the list
        try:
            number = int(result[-8:-4])
            results.append(number)
        except Exception as excep:
            if VERBOSE:
                print(f"Exception parsing the following report: {result}")
                print(excep)


    if results:
        # Sort reverse the list and get the first element, then sum one and fill it with
        # zeros so it can be taken as the full ID
        results.sort(reverse=True)
        last_id = results[0] + 1
        return str(last_id).zfill(4)

    return "0000"

###############################################################################################

def validate_system():
    """
    Checks if all needed packages to run this tool are available
    """

    if VERBOSE:
        print("validate_system")

    # Check for scap-security-guide suit which depens on oscap
    rc = subprocess.call(
        ["rpm", "-q", SCAP_SEC_TOOL],
        stdout = (subprocess.DEVNULL if not VERBOSE else None),
        stderr = (subprocess.DEVNULL if not VERBOSE else None)
    )

    if rc != 0:
        print(f"Package {SCAP_SEC_TOOL} is not installed")
        return 1

    # Check for Oracle Linux Server 8
    is_ol8 = False
    with open("/etc/os-release", "r") as file:
        is_ol8 = False
        for line in file:
            if "platform:el8" in line:
                if VERBOSE:
                    print(f"validate_system : {line}")
                is_ol8 = True
                break

    if is_ol8 is False:
        print("This tool is designed for Oracle Linux Server 8")
        return 1

    return rc

###############################################################################################

def set_environment():
    """
    Prepare the system for execution
    """

    if VERBOSE:
        print("set_environment")

    os.makedirs(os.path.expanduser(SCAN_STIG_HOME_DIR), exist_ok=True)

###############################################################################################

def run_scan(args):
    """
    Execute scan and print scan report in the output
    """
    if VERBOSE:
        print("run_scan")

    scan_id = get_new_scan_id()

    # Get the starting date
    now = datetime.now().strftime("%d%m%Y%H%M%S")

    # Let oscap remove the files if they already exists
    tmp_result = f"/tmp/result_{now}{scan_id}.xml"
    tmp_report = f"/tmp/report_{now}{scan_id}.html"

    print(f"Generating scan ID {now}{scan_id}")
    # Form the command to scan the system using the STIG profile
    cmd = [
        "oscap", "xccdf", "eval", "--profile", STIG_PROFILE, 
        "--results", tmp_result, "--report", tmp_report, DATA_STREAM_LOC
    ]

    # We don't care about STDOUT/
    rc = subprocess.call(cmd,
        stdout = (subprocess.DEVNULL if not VERBOSE else None),
        stderr = (subprocess.DEVNULL if not VERBOSE else None)
    )

    # All rules passed
    if rc == 0:
        print(f"All rules defined for {STIG_PROFILE} were passed")
    # Something went wrong during evaluation
    elif rc == 1:
        print("oscap evaluation went wrong")
    # Rules failed or unknown results
    else:
        print(f"Some rules defined for {STIG_PROFILE} were not passed")

    # Save scan
    if rc != 1:
        os.rename(tmp_result, tmp_result.replace("/tmp", os.path.expanduser(SCAN_STIG_HOME_DIR)))
        os.rename(tmp_report, tmp_report.replace("/tmp", os.path.expanduser(SCAN_STIG_HOME_DIR)))

    return rc

###############################################################################################

def list_scans(args):
    """
    List history of executed scans printing scan ids
    """
    if VERBOSE:
        print("list_scans")

    rc = 0
    results = []

    for result in get_results():
        # Get the ID only and convert it do interger so we can sort the list
        try:
            results.append(result[-22:-4])
        except Exception as excep:
            if VERBOSE:
                print(f"Exception parsing the following report: {result}")
                print(excep)

    if results:
        print(f"{len(results)} scan IDs were found:")
        results.sort()
        for result in results:
            print(f"\t{result}")
    else:
        print("Scans not found")

    return rc

###############################################################################################

def print_scan(args):
    """
    Print scan report by scan id available from the history
    """

    scan_id = args.id[0]

    if VERBOSE:
        print(f"print_scan : {scan_id}")

    rc = 1

    for result in get_results():
        if scan_id in result:
            print_scan_summary(result)
            return 0

    print(f"Scan id {scan_id} was not found")
    return rc

###############################################################################################

def compare_scans(args):
    """
    Compare two scan reports available from the history by scan ids.
    Print following:
        Summary statistics for scan 1 (id/total/passed/failed)
        Summary statistics for scan 2 (id/total/passed/failed)
        Summary statistics for fixed/introduced results diff between scan 1 and scan 2
    """

    scan_id1 = args.id1[0]
    scan_id2 = args.id2[0]

    if VERBOSE:
        print(f"compare_scans : {scan_id1} {scan_id2}")

    result1 = ""
    result2 = ""

    for result in get_results():
        if scan_id1 in result:
            result1 = result
        if scan_id2 in result:
            result2 = result

    if not result1:
        print(f"Scan id {scan_id1} was not found")
        return 1
    if not result2:
        print(f"Scan id {scan_id2} was not found")
        return 1

    report1 = print_scan_summary(result1, "ID 1")
    report2 = print_scan_summary(result2, "ID 2")

    # Make the magic here for both reports
    print_scan_compare_summary(report1, report2)
    return 0


###############################################################################################

def main(args):
    """
    Main program
    """
    global VERBOSE

    # Process tool arguments
    description = """
Command line tool for regular "openscap" scans of the Oracle Linux 8 system using
available "stig" profile from the "scap-security-guide" package.
"""

    epilog = """
The following commands are supported:

    scan
       Scan the current system agaist the STIG profile.

       If the scan is performed correctly, an 18 digits scan ID is printed in
       the standard output for future references.

    list
       List history of executed scan IDs.

    print [id]
       Print a given scan ID report.

    compare [id1, id2]
       Compare two given scan ID reports.
       

"""

    parser = argparse.ArgumentParser(description = description[1:],
                                     epilog = epilog[1:],
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     add_help = False)

    parser.add_argument("-h", "--help", action="help", default=argparse.SUPPRESS,
                        help="Show this help message and exit")

    parser.add_argument("-v", "--verbose", default=False, action='store_true',
                        help="Verbose (print extra useful information)")

    subparser = parser.add_subparsers(help="Commands\n")

    # Scan system against STIG profile
    parser_scan = subparser.add_parser("scan", help="Scan the current system agaist the \
        STIG profile")
    parser_scan.set_defaults(action="scan", func=run_scan)

    # List a previous scan IDs in the system
    parser_list = subparser.add_parser("list", help="List previous scans in the system")
    parser_list.set_defaults(action="list", func=list_scans)

    # Print a given scan ID
    parser_print = subparser.add_parser("print", help="Print the given scan ID")
    parser_print.add_argument("id", nargs=1, type=validate_id, help="Scan ID to print")
    parser_print.set_defaults(action="print", func=print_scan)

    # Print two given scan IDs
    parser_compare = subparser.add_parser("compare", help="Compare and print two given \
        scan IDs")
    parser_compare.add_argument("id1", nargs=1, type=validate_id, help="Scan ID to \
        compare")
    parser_compare.add_argument("id2", nargs=1, type=validate_id, help="Scan ID to \
        compare")
    parser_compare.set_defaults(action="compare", func=compare_scans)


    if not args:
        parser.print_usage()
        print("\nUse the -h or --help flag for more detailed information")
        return 1

    settings = parser.parse_args(args=args)

    if settings.action == None:
        print("No command provided")
        return 1

    if settings.verbose:
        VERBOSE = settings.verbose

    # Check for dependencies
    rc = validate_system()

    # Missing dependencies?
    if rc != 0:
        return 2

    # Prepare the environment
    set_environment()

    return settings.func(settings)

###############################################################################################

if __name__ == '__main__':
    try:
        sys.exit(main(sys.argv[1:]))
    except Exception:
        print(f"Error while running {sys.argv[0]}")
        traceback.print_exc()
        sys.exit(99)

###############################################################################################
